CPU寄存器，与程序计数器（存储CPU正在执行的指令位置，或者即将执行的下一条指令的位置）共同组成CPU上下文。

CPU上下文切换指的是：把前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些寄存器和程序计数器上，最后再跳转到程序计数器所指的新位置，运行新的任务。被保存下来的上下文会存储在系统内核中，等任务重新调度执行时再次加载进来。

根据任务的不同，CPU的上下文切换可以分为几个不同场景（进程上下文切换、线程上下文切换、中断上下文切换）

### 进程上下文切换
1. 每个进程都有一个PCB，每个PCB里都有独立的程序计数器和上下文信息。
2. 有一个进程a一个进程b，进程a去cpu上运行其代码，这个运行不是无节制的，而是有一个时间片的东西会遏制运行时间，若进程a的时间片到了，则会被切换出来。
3. 此时有两个非常重要的东西，程序计数器（保存程序即将要执行的下一条指令的地址），和上下文信息（保存寄存器当中的值即目前执行结果），二者都在task_struct结构体中。
4. 进程a被切换出后，若再次占用CPU时，恢复现场后，从刚刚执行的代码往下运行。

#### 性能问题
进程由内核管理和调度，进程的切换只能发生在内核态，进程上下文不仅包括虚拟内存、栈、全局变量等用户空间资源，还包括内核堆栈、寄存器等内核空间状态。每次进程上下文切换需要几十纳秒到数微秒的CPU时间。

进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是TLB（translation Lookaside Buffer，本质上就是一个cache，是用来加速页表查找的）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后TLB就失效了，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此通常线程切换要比较进程切换块。

### 线程上下文切换
当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。

线程主要就是私有数据、栈和寄存器等资源。

线程上下文切换分为两种情况：
1. 两个线程属于不同线程，资源不共享，所以等同于进程上下文切换
2. 两个线程属于同一个进程，只需要切换私有数据、寄存器等不共享的数据

### 中断上下文切换
与系统调用不同，中断上下文切换不涉及进程的用户态。所以中断过程打断了一个正处于用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户资源。它只包括内核态中断服务程序执行所必须的状态：CPU寄存器、内核堆栈、硬件中断参数