## GC回收目标
1. golang的垃圾回收是针对堆的
2. 引用类型的全局变量内存分配在堆，值类型的全局变量分配在栈
3. 局部变量内存分配可能在栈也可能在堆

```
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}

go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。
```

## GC过程
### Go V1.5
#### 三色标记法
三色抽象定义了三种不同类型的对象，并用不同的颜色相称：
- 白色：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象
- 灰色：正在搜索的对象，该类对象可能还存在外部引用对象
- 黑色：已搜索完的对象，这类对象不再有外部引用对象

```
根节点对象 主要指执行 GC 时刻所有的 全局对象 和 栈上的对象（函数参数与内部变量）。
```
1. 初始状态下所有对象都是 白色 的；
2. 从 根节点对象 开始遍历所有对象，把遍历到的对象变成 灰色，放入待处理队列；
3. 遍历所有灰色对象，将遍历到的灰色对象变成 黑色，同时将它引用的对象变成灰色并加入到待处理队列；
4. 循环步骤3，直到 待处理队列为空（所有灰色对象都变为黑色）；
5. 剩下没有被标记的 白色 对象就认为是垃圾对象。

#### 插入写屏障
1. 程序开始，全部标记为白色
2. 所有的对象放到白色集合
3. 遍历一次根节点，得到灰色节点
4. 遍历灰色节点，将可达的对象，从白色标记灰色，遍历之后的灰色标记成黑色
5. 由于并发特性，此刻外界向在堆中的对象发生添加对象，以及在栈中的对象添加对象，在堆中的对象会触发插入屏障机制，栈中的对象不触发
6. 由于堆中对象插入屏障，则会把堆中黑色对象添加的白色对象改成灰色，栈中的黑色对象添加的白色对象依然是白色
7. 循环第 5 步，直到没有灰色节点
8. 在准备回收白色前，重新遍历扫描一次栈空间，加上 STW 暂停保护栈，防止外界干扰（有新的白色会被添加成黑色）在 STW 中，将栈中的对象一次三色标记，直到没有灰色
9. 停止 STW，清除白色。

#### 删除写屏障
1. 遍历灰色节点的时候出现可达的节点被删除
2. 触发删除写屏障，这个可达的被删除的节点也是灰色
3. 循环三色标记之后，直到没有灰色节点
4. 然后清理白色，删除写屏障会造成一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮 GC 中被清理掉

### Go V1.8
#### 混合写屏障
1. GC 开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需 STW)
2. GC 期间，任何在栈上创建的新对象，均为黑色
3. 被删除的对象标记为灰色
4. 被添加的对象标记为灰色。

## GC触发时机
- gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。
- gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟。
- gcTriggerCycle：如果没有开启 GC，则启动 GC。
- 手动触发的 runtime.GC 方法。