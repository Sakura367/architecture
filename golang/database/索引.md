## 聚簇索引
- 在 PRIMARY KEY 表上 定义a 时， InnoDB 将其用作聚簇索引。 为您创建的每个表定义主键。 如果没有逻辑唯一且非空列或列集，请添加一个新的 自动增量 列，其值将自动填充。
- 如果没有 PRIMARY KEY 为表 定义一个 ，MySQL将找到 UNIQUE 所有键列 所在的第一个 非空索引，将 InnoDB 其用作聚簇索引。
- 如果表没有 PRIMARY KEY 或 没有 合适的 UNIQUE 索引，则在 InnoDB 内部生成一个隐藏的聚簇索引 GEN_CLUST_INDEX ，该 索引 在包含行ID值的合成列上 命名 。 行按照 InnoDB 分配给此类表中的行 的ID排序 。 行ID是一个6字节的字段，随着新行的插入而单调增加。 因此，由行ID排序的行在物理上处于插入顺序。
##### 使用自增id作为主键索引
InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+树）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置。此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁地移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

## 覆盖索引
MySQL 执行计划 explain 结果里的 key 有使用索引，如果 select 后面查询的字段都可以从这个索引的树中获取，这种情况一般可以说是用到了覆盖索引，extra 里一般都有 using index；覆盖索引一般针对的是辅助索引，整个査询结果只通过辅助索引就能拿到结果，不需要通过辅助索引树找到主键，再通过主键去主键索引树里获取其它字段值。

## 联合索引
两个或更多个列上的索引被称作联合索引，联合索引又叫组合索引。
例如索引是 `key index (a,b,c)` 可以支持 `a | a,b| a,b,c` 3 种组合进行查找，但不支持 `b,c` 进行查找。在使用的时候，`a,c` 组合也可以用，但实际上只用到了 `a` 的索引。
查询条件为 `b,a` 为自动调整为 `a,b` 。
- 组合索引与多个单列索引区别
  - 组合索引根据最左匹配原则进行索引匹配；同时相比多个单列索引只需要建立一个索引，节省空间；只适用 and 条件下查询，or 条件不可
  - 多个单列索引，mysql一般使用区分度更大的字段进行索引优化

## 索引失效
1. 违反最左前缀法则：查询未从索引的最左前列开始或者跳过索引中的列
2. 在索引列上做任何操作：如计算、函数、（自动or手动）类型转换等操作
3. 索引范围条件右边的列
4. 尽量使用覆盖索引：只访问索引查询（索引列和查询列一致），减少select*
5. 使用不等于（!=、<>）：使用不等于（!=、<>）的时候无法使用索引会导致全表扫描（除覆盖索引外）
6. like 以通配符开头（'% abc'）
7. 字符串不加单引号索引失效
8. or 连接
9. order by、group by